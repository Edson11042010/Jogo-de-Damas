<!DOCTYPE html>
<html lang="pt-BR">
<head>

  <!-- Cabeçalho do código: define metadados, título e CSS -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Damas</title>
  <!-- Link para o arquivo CSS externo -->
  <link rel="stylesheet" href="DAMAS EPA 2025.css">

</head>
<body>

<!-- Corpo do código: elementos visíveis no site -->
<div class="topo">Jogo de Damas</div> <!-- Cabeçalho do jogo -->

<!-- Botão para reiniciar o jogo -->
<button onclick="reiniciar()"> Reiniciar</button>

<!-- Placar do jogo -->
<div class="placar">
   Vermelho: <span id="pontosRed">0</span> |  Preto: <span id="pontosBlack">0</span>
</div>

<!-- Tabuleiro do jogo -->
<div class="board" id="board"></div>

<!-- Script JavaScript para funcionamento do jogo -->
<script>
/* Tamanho do tabuleiro */
const SIZE = 8;

/* Estado do tabuleiro: array 2D, posição selecionada, jogador atual e pontos */
let board = [];
let selected = null;
let currentPlayer = "red";
let pontos = { red:0, black:0 };

/* Referência ao elemento HTML do tabuleiro */
const boardEl = document.getElementById("board");

/* Função que cria o tabuleiro inicial */
function createBoard() {
  boardEl.innerHTML = ""; // limpa o tabuleiro HTML
  board = [];             // limpa array do tabuleiro
  pontos = { red:0, black:0 }; // reseta pontos
  updatePlacar();         // atualiza o placar
  selected = null;        // nenhuma peça selecionada
  currentPlayer = "red";  // jogador vermelho começa

  for(let r=0; r<SIZE; r++){
    let row = [];
    for(let c=0; c<SIZE; c++){
      // Cria cada célula do tabuleiro
      const cell = document.createElement("div");
      cell.className = "cell " + ((r+c)%2===0 ? "light":"dark"); // alterna cores
      cell.dataset.row = r; // armazena linha
      cell.dataset.col = c; // armazena coluna
      cell.addEventListener("click",()=>handleClick(r,c)); // clique na célula

      // Coloca peças nos primeiros 3 e últimos 3 linhas
      if((r+c)%2===1){ // apenas nas casas escuras
        if(r<3){ 
          cell.appendChild(createPiece("black")); // peça preta
          row.push("black"); 
        } else if(r>4){ 
          cell.appendChild(createPiece("red")); // peça vermelha
          row.push("red"); 
        } else row.push(null); // casa vazia
      } else row.push(null); // casa clara vazia

      boardEl.appendChild(cell);
    }
    board.push(row); // adiciona linha ao tabuleiro
  }
}

/* Função que cria uma peça */
function createPiece(color){
  const piece = document.createElement("div");
  piece.className = "piece " + color; // cor da peça
  if(color.includes("king")) piece.classList.add("king"); // se for dama, adiciona classe
  return piece;
}

/* Função que lida com o clique do jogador */
function handleClick(r,c){
  const cellValue = board[r][c];
  // Se clicar na própria peça
  if(cellValue && cellValue.startsWith(currentPlayer)){
    clearSelection(); // limpa seleção anterior
    selected = {r,c}; // marca peça selecionada
    getCell(r,c).classList.add("selected"); // destaca visualmente
  } 
  // Se clicar em célula vazia e tiver peça selecionada
  else if(!cellValue && selected){
    movePiece(selected.r, selected.c, r, c); // tenta mover peça
  }
}

/* Função que move uma peça */
function movePiece(r1,c1,r2,c2){
  let piece = board[r1][c1];
  if(!isValidMove(r1,c1,r2,c2,piece)) return; // valida movimento

  // captura de peça adversária
  if(Math.abs(r2-r1)===2 && Math.abs(c2-c1)===2){
    const midRow = (r1+r2)/2;
    const midCol = (c1+c2)/2;
    board[midRow][midCol] = null; // remove peça capturada
    pontos[currentPlayer]++;       // soma ponto
    updatePlacar();
  }

  // move a peça
  board[r1][c1] = null;
  board[r2][c2] = piece;

  // promoção para dama
  if(piece==="red" && r2===0) board[r2][c2]="red-king";
  if(piece==="black" && r2===SIZE-1) board[r2][c2]="black-king";

  redrawBoard(); // atualiza visual do tabuleiro

  // captura múltipla
  if(Math.abs(r2-r1)===2){
    selected = {r:r2, c:c2};
    getCell(r2,c2).classList.add("selected");
    if(temCaptura(r2,c2, board[r2][c2])) return; // permite nova captura
  }

  selected = null; // desmarca peça
  currentPlayer = currentPlayer==="red" ? "black" : "red"; // troca jogador
}

/* Função que valida se o movimento é permitido */
function isValidMove(r1,c1,r2,c2,piece){
  if(board[r2][c2]) return false; // célula ocupada
  const isKing = piece.includes("king");
  const dir = piece.startsWith("red")?-1:1; // direção da peça

  // movimento simples (uma casa diagonal)
  if(Math.abs(c1-c2)===1 && (isKing || r2-r1===dir)) return true;

  // movimento de captura (duas casas diagonal)
  if(Math.abs(c1-c2)===2 && (isKing || r2-r1===dir*2)){
    const midRow = (r1+r2)/2;
    const midCol = (c1+c2)/2;
    // só permite se houver peça adversária no meio
    if(board[midRow][midCol] && !board[midRow][midCol].startsWith(piece.split("-")[0])) return true;
  }
  return false;
}

/* Função que verifica se há captura possível a partir de uma posição */
function temCaptura(r,c,piece){
  const isKing = piece.includes("king");
  const dirs = isKing ? [[1,1],[1,-1],[-1,1],[-1,-1]] : 
               (piece.startsWith("red")?[[-1,1],[-1,-1]]:[[1,1],[1,-1]]);
  for(const [dr,dc] of dirs){
    const midR = r+dr;
    const midC = c+dc;
    const endR = r+dr*2;
    const endC = c+dc*2;
    if(endR>=0 && endR<SIZE && endC>=0 && endC<SIZE){
      if(board[midR][midC] && !board[midR][midC].startsWith(piece.split("-")[0]) && !board[endR][endC]){
        return true; // existe captura disponível
      }
    }
  }
  return false;
}

/* Função que retorna a célula HTML pelo índice */
function getCell(r,c){ return boardEl.children[r*SIZE+c]; }

/* Função que redesenha todo o tabuleiro */
function redrawBoard(){
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell = getCell(r,c);
      cell.innerHTML=""; // limpa célula
      cell.classList.remove("selected"); // remove destaque
      if(board[r][c]) cell.appendChild(createPiece(board[r][c])); // adiciona peça
    }
  }
}

/* Função que limpa a seleção visual das peças */
function clearSelection(){
  for(let i=0;i<boardEl.children.length;i++) boardEl.children[i].classList.remove("selected");
}

/* Função que reinicia o jogo */
function reiniciar(){ createBoard(); }

/* Função que atualiza o placar no HTML */
function updatePlacar(){
  document.getElementById("pontosRed").innerText = pontos.red;
  document.getElementById("pontosBlack").innerText = pontos.black;
}

/* Cria o tabuleiro ao carregar a página */
createBoard();
</script>
</body>
</html>
